<?php

/**
 * Plugin GLPI AI CHAT - File: license.class.php
 * License management for the GLPI AI Chat plugin.
 */

if (!defined('GLPI_ROOT')) {
   die("Sorry. You can't access this file directly");
}

/**
 * License management for the glpiaichat plugin.
 *
 * - License format: base64(JSON) . '.' . base64(SIGNATURE)
 * - JSON contains: plugin, domain, glpi_uuid, issued_at, expires_at
 * - Ed25519 signature (libsodium) on the JSON payload
 * - Verification using the integrated public key
 *
 * Source of truth:
 * - File: GLPI_ROOT/plugins/glpiaichat/keys/licence.txt
 * - Fallback: "license_key" field stored in the GLPI Config table
 *
 * Database fields (license_expires_at, license_status, etc.) are used 
 * for UI display only and do not dictate the validity check.
 */
class PluginGlpiaichatLicense {

   /** GLPI configuration section */
   private const CONFIG_SECTION = 'glpiaichat';

   /** Relative path to the license file within the plugin */
   private const LICENSE_REL_PATH = '/plugins/glpiaichat/keys/licence.txt';

   /**
    * Public key (base64) generated by keys/license_tool.php
    */
   private const PUBLIC_KEY_B64 = 'krGRLCOHtBSsITV8FbtLoXiqEp9qABBl9JEJQ7oZeMY=';

   /** Expected plugin name in the license JSON payload */
   private const EXPECTED_PLUGIN = 'glpiaichat';

   // =====================================================================
   // GLPI Config management (cache / display)
   // =====================================================================

   /**
    * Loads the "license" configuration from the GLPI Config table.
    * * @return array
    */
   public static function loadConfig(): array {
      return Config::getConfigurationValues(self::CONFIG_SECTION, [
         'license_key',
         'license_status',
         'license_expires_at',
         'license_last_check',
         'license_message',
      ]);
   }

   /**
    * Saves the "license" configuration to the GLPI Config table.
    * * @param array $data Configuration data to save
    */
   private static function saveConfig(array $data): void {
      $allowed = [
         'license_key',
         'license_status',
         'license_expires_at',
         'license_last_check',
         'license_message',
      ];

      $toSave = [];
      foreach ($allowed as $k) {
         if (array_key_exists($k, $data)) {
            $toSave[$k] = $data[$k];
         }
      }

      if (!empty($toSave)) {
         Config::setConfigurationValues(self::CONFIG_SECTION, $toSave);
      }
   }

   // =====================================================================
   // Raw license retrieval (file + DB fallback)
   // =====================================================================

   /**
    * Returns the raw license string:
    * 1) From GLPI_ROOT/plugins/glpiaichat/keys/licence.txt
    * 2) Fallback to the database (license_key field)
    * * @return string
    */
   private static function getRawLicense(): string {
      // 1) Check for license file in the plugin directory
      $licenseFile = rtrim(GLPI_ROOT, DIRECTORY_SEPARATOR) . self::LICENSE_REL_PATH;

      if (is_readable($licenseFile)) {
         $content = trim((string)file_get_contents($licenseFile));
         if ($content !== '') {
            return $content;
         }
      }

      // 2) Fallback: stored in DB (manual entry)
      $conf = self::loadConfig();
      $key  = trim((string)($conf['license_key'] ?? ''));

      return $key;
   }

   // =====================================================================
   // Public API
   // =====================================================================

   /**
    * Indicates if the license is currently valid.
    * * Does NOT rely on database fields but re-verifies the actual 
    * license string (signature, domain, and expiration).
    * * @return bool
    */
   public static function isValid(): bool {
      $license = self::getRawLicense();

      if ($license === '') {
         return false;
      }

      try {
         [$valid] = self::verifyLicense($license);
         return $valid;
      } catch (\Throwable $e) {
         return false;
      }
   }

   /**
    * Returns the detailed license status for UI display.
    * * @return array
    */
   public static function getStatus(): array {
      $conf    = self::loadConfig();
      $license = self::getRawLicense();

      $result = [
         'valid'       => false,
         'license_key' => $license,
         'status'      => 'none',
         'expires_at'  => '',
         'last_check'  => $conf['license_last_check'] ?? '',
         'message'     => $conf['license_message'] ?? '',
      ];

      if ($license === '') {
         $result['message'] = __('Aucune licence trouvée (fichier ou configuration).', 'glpiaichat');
         return $result;
      }

      try {
         [$valid, $payload, $msg] = self::verifyLicense($license);

         $result['valid']   = $valid;
         $result['status']  = $valid ? 'valid' : 'invalid';
         $result['message'] = $msg;

         if (isset($payload['expires_at'])) {
            $result['expires_at'] = $payload['expires_at'];
         }

      } catch (\Throwable $e) {
         $result['valid']   = false;
         $result['status']  = 'invalid';
         $result['message'] = __('Erreur de vérification :', 'glpiaichat') . ' ' . $e->getMessage();
      }

      return $result;
   }

   /**
    * Activates a license key entered manually in the configuration form.
    * * @param string $key The license key to activate
    * @return array
    */
   public static function activate(string $key): array {
      $key = trim($key);

      if ($key === '') {
         $emptyMsg = __('Clé de licence vide.', 'glpiaichat');
         self::saveConfig([
            'license_key'        => '',
            'license_status'     => 'invalid',
            'license_expires_at' => '',
            'license_last_check' => date('Y-m-d H:i:s'),
            'license_message'    => $emptyMsg,
         ]);

         return [
            'success'    => false,
            'error'      => 'empty_key',
            'status'     => 'invalid',
            'message'    => $emptyMsg,
            'expires_at' => null,
         ];
      }

      // Real check of the signed license
      try {
         [$valid, $payload, $msg] = self::verifyLicense($key);

         $expiresAt = $payload['expires_at'] ?? null;

         self::saveConfig([
            'license_key'        => $key,
            'license_status'     => $valid ? 'valid' : 'invalid',
            'license_expires_at' => $expiresAt ?? '',
            'license_last_check' => date('Y-m-d H:i:s'),
            'license_message'    => $msg,
         ]);

         return [
            'success'    => $valid,
            'error'      => $valid ? null : 'invalid_license',
            'status'     => $valid ? 'valid' : 'invalid',
            'message'    => $msg,
            'expires_at' => $expiresAt,
         ];

      } catch (\Throwable $e) {
         $msg = __('Erreur lors de la vérification de la licence :', 'glpiaichat') . ' ' . $e->getMessage();

         self::saveConfig([
            'license_key'        => $key,
            'license_status'     => 'invalid',
            'license_expires_at' => '',
            'license_last_check' => date('Y-m-d H:i:s'),
            'license_message'    => $msg,
         ]);

         return [
            'success'    => false,
            'error'      => 'verification_error',
            'status'     => 'invalid',
            'message'    => $msg,
            'expires_at' => null,
         ];
      }
   }

   // =====================================================================
   // Technical license verification (signature + logic)
   // =====================================================================

   /**
    * Returns the binary public key decoded from base64.
    * * @return string
    */
   private static function getPublicKey(): string {
      $pk = base64_decode(self::PUBLIC_KEY_B64, true);
      if ($pk === false) {
         throw new \RuntimeException(__('Clé publique invalide (Base64).', 'glpiaichat'));
      }
      return $pk;
   }

   /**
    * Verifies the license payload:
    * - format check
    * - Ed25519 signature verification
    * - plugin, domain, GLPI instance UUID, and expiration check
    * * @param string $license The raw license string
    * @return array [bool $valid, array $payload, string $message]
    */
   private static function verifyLicense(string $license): array {
      if (!extension_loaded('sodium')) {
         throw new \RuntimeException(__('Extension sodium requise pour vérifier la licence.', 'glpiaichat'));
      }

      if (strpos($license, '.') === false) {
         throw new \InvalidArgumentException(__('Format de licence invalide (séparateur manquant).', 'glpiaichat'));
      }

      [$jsonB64, $sigB64] = explode('.', $license, 2);

      $json      = base64_decode($jsonB64, true);
      $signature = base64_decode($sigB64, true);

      if ($json === false || $signature === false) {
         throw new \InvalidArgumentException(__('Licence corrompue (Base64 invalide).', 'glpiaichat'));
      }

      $publicKey = self::getPublicKey();

      if (!sodium_crypto_sign_verify_detached($signature, $json, $publicKey)) {
         throw new \RuntimeException(__('Signature de licence invalide.', 'glpiaichat'));
      }

      $payload = json_decode($json, true);
      if (!is_array($payload)) {
         throw new \RuntimeException(__('Payload JSON invalide dans la licence.', 'glpiaichat'));
      }

      $messageParts = [];

      // 1) Plugin name verification
      $plugin = $payload['plugin'] ?? '';
      if ($plugin !== self::EXPECTED_PLUGIN) {
         throw new \RuntimeException(__('Cette licence ne correspond pas à ce plugin.', 'glpiaichat'));
      }

      // 2) GLPI Instance UUID verification
      if (!isset($payload['glpi_uuid']) || !is_string($payload['glpi_uuid']) || trim($payload['glpi_uuid']) === '') {
         throw new \RuntimeException(__('Champ glpi_uuid manquant dans la licence.', 'glpiaichat'));
      }

      $licensedUuid = trim($payload['glpi_uuid']);
      $coreConf    = Config::getConfigurationValues('core', ['uuid']);
      $currentUuid = trim((string)($coreConf['uuid'] ?? ''));

      if ($currentUuid !== '' && $licensedUuid !== $currentUuid) {
         throw new \RuntimeException(__('Cette licence est liée à une autre instance GLPI.', 'glpiaichat'));
      }

      $messageParts[] = __('Instance GLPI autorisée.', 'glpiaichat');

      // 3) Expiration check
      if (!isset($payload['expires_at'])) {
         throw new \RuntimeException(__('Champ expires_at manquant dans la licence.', 'glpiaichat'));
      }

      $expTs = strtotime($payload['expires_at'] . ' 23:59:59');
      if ($expTs === false) {
         throw new \RuntimeException(__("Date d'expiration invalide dans la licence.", 'glpiaichat'));
      }
      if ($expTs < time()) {
         throw new \RuntimeException(__('Licence expirée.', 'glpiaichat'));
      }

      $messageParts[] = __('Valide jusqu\'au', 'glpiaichat') . ' ' . date('d/m/Y', $expTs);

      // 4) Domain verification
      if (!isset($payload['domain'])) {
         throw new \RuntimeException(__('Champ domain manquant dans la licence.', 'glpiaichat'));
      }

      $licenseDomain = strtolower($payload['domain']);
      $currentDomain = strtolower($_SERVER['HTTP_HOST'] ?? '');

      if ($currentDomain !== '') {
         if ($currentDomain !== $licenseDomain) {
            throw new \RuntimeException(sprintf(
               __('Domaine non autorisé. Licence pour "%s", instance actuelle : "%s".', 'glpiaichat'),
               $licenseDomain,
               $currentDomain
            ));
         }
         $messageParts[] = __('Domaine autorisé :', 'glpiaichat') . ' ' . $licenseDomain;
      } else {
         // CLI / CRON context
         $messageParts[] = __('Domaine non vérifié (contexte CLI/CRON, HTTP_HOST vide).', 'glpiaichat');
      }

      $message = implode(' | ', $messageParts);

      return [true, $payload, $message];
   }
}
